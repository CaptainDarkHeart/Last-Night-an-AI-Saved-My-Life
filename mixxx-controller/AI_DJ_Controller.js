/**
 * AI DJ Controller for Mixxx
 *
 * Automated DJ performance system that executes playlists generated by the
 * Track Selection Engine (Layer 3) with extended blends and beatmatching.
 *
 * Features:
 * - Reads playlist JSON from Track Selection Engine
 * - Executes 60-90 second extended blends
 * - Beatmatching and tempo sync
 * - Automatic crossfading
 * - Cue point management
 * - Energy-aware mixing
 */

var AI_DJ = {};

// Configuration
AI_DJ.config = {
    blendDuration: 75,          // Default blend duration in seconds
    preloadTime: 30,            // Time before transition to load next track (seconds)
    beatmatchTolerance: 0.02,   // BPM tolerance for beatmatching (2%)
    enableSync: true,           // Use Mixxx sync for beatmatching
    enableLogging: true,        // Console logging
    playlistPath: "",           // Path to playlist JSON (set by user)
};

// State
AI_DJ.state = {
    playlist: null,             // Loaded playlist data
    currentTrackIndex: 0,       // Current track in playlist
    activeDeck: "[Channel1]",   // Currently playing deck
    nextDeck: "[Channel2]",     // Deck for next track
    isTransitioning: false,     // Currently in a blend
    transitionTimer: null,      // Timer for transition execution
    monitorTimer: null,         // Timer for position monitoring
};

// Logging
AI_DJ.log = function(message) {
    if (AI_DJ.config.enableLogging) {
        console.log("[AI_DJ] " + message);
    }
};

AI_DJ.error = function(message) {
    console.error("[AI_DJ ERROR] " + message);
};

// Initialize
AI_DJ.init = function() {
    AI_DJ.log("Initializing AI DJ Controller...");

    // Connect to deck events
    engine.makeConnection("[Channel1]", "play", AI_DJ.onPlayChanged);
    engine.makeConnection("[Channel2]", "play", AI_DJ.onPlayChanged);
    engine.makeConnection("[Channel1]", "playposition", AI_DJ.onPositionChanged);
    engine.makeConnection("[Channel2]", "playposition", AI_DJ.onPositionChanged);

    // Start monitoring timer (check every 100ms)
    AI_DJ.state.monitorTimer = engine.beginTimer(100, AI_DJ.monitorPlayback, false);

    AI_DJ.log("AI DJ Controller initialized");
};

// Shutdown
AI_DJ.shutdown = function() {
    AI_DJ.log("Shutting down AI DJ Controller...");

    if (AI_DJ.state.monitorTimer) {
        engine.stopTimer(AI_DJ.state.monitorTimer);
    }
    if (AI_DJ.state.transitionTimer) {
        engine.stopTimer(AI_DJ.state.transitionTimer);
    }

    AI_DJ.log("AI DJ Controller shut down");
};

// Load playlist from JSON file
AI_DJ.loadPlaylist = function(playlistData) {
    try {
        AI_DJ.state.playlist = playlistData;
        AI_DJ.state.currentTrackIndex = 0;

        AI_DJ.log("Playlist loaded: " + AI_DJ.state.playlist.name);
        AI_DJ.log("Total tracks: " + AI_DJ.state.playlist.tracks.length);

        return true;
    } catch (e) {
        AI_DJ.error("Failed to load playlist: " + e);
        return false;
    }
};

// Start automated DJ performance
AI_DJ.start = function() {
    if (!AI_DJ.state.playlist) {
        AI_DJ.error("No playlist loaded. Call AI_DJ.loadPlaylist() first.");
        return false;
    }

    AI_DJ.log("Starting automated DJ performance...");

    // Load first track on Channel 1
    AI_DJ.loadTrack(0, AI_DJ.state.activeDeck);

    // Start playback
    engine.setValue(AI_DJ.state.activeDeck, "play", 1);

    AI_DJ.log("Performance started!");
    return true;
};

// Stop automated DJ performance
AI_DJ.stop = function() {
    AI_DJ.log("Stopping automated DJ performance...");

    // Stop both decks
    engine.setValue("[Channel1]", "play", 0);
    engine.setValue("[Channel2]", "play", 0);

    // Reset state
    AI_DJ.state.currentTrackIndex = 0;
    AI_DJ.state.isTransitioning = false;

    AI_DJ.log("Performance stopped");
};

// Load track by index
AI_DJ.loadTrack = function(trackIndex, deck) {
    if (!AI_DJ.state.playlist) {
        AI_DJ.error("No playlist loaded");
        return false;
    }

    if (trackIndex >= AI_DJ.state.playlist.tracks.length) {
        AI_DJ.log("End of playlist reached");
        return false;
    }

    var track = AI_DJ.state.playlist.tracks[trackIndex];

    AI_DJ.log("Loading track " + (trackIndex + 1) + "/" + AI_DJ.state.playlist.tracks.length);
    AI_DJ.log("  Artist: " + track.artist);
    AI_DJ.log("  Title: " + track.title);
    AI_DJ.log("  BPM: " + track.bpm);
    AI_DJ.log("  Energy: " + track.energy_level);

    // In a real implementation, you would:
    // 1. Search library for the track by artist/title
    // 2. Load it to the deck
    // For now, we'll use LoadSelectedTrack and assume the track is already selected

    // engine.setValue(deck, "LoadSelectedTrack", 1);

    return true;
};

// Monitor playback position
AI_DJ.monitorPlayback = function() {
    if (!AI_DJ.state.playlist || AI_DJ.state.isTransitioning) {
        return;
    }

    var activeDeck = AI_DJ.state.activeDeck;
    var isPlaying = engine.getValue(activeDeck, "play");

    if (!isPlaying) {
        return;
    }

    var duration = engine.getValue(activeDeck, "duration");
    var playposition = engine.getValue(activeDeck, "playposition");
    var timeRemaining = duration * (1 - playposition);

    // Get transition info
    var currentIndex = AI_DJ.state.currentTrackIndex;
    if (currentIndex >= AI_DJ.state.playlist.transitions.length) {
        return; // No more transitions
    }

    var transition = AI_DJ.state.playlist.transitions[currentIndex];
    var blendDuration = transition.blend_duration || AI_DJ.config.blendDuration;

    // Check if it's time to start the blend
    if (timeRemaining <= blendDuration && !AI_DJ.state.isTransitioning) {
        AI_DJ.log("Transition point reached!");
        AI_DJ.startTransition(currentIndex + 1, transition);
    }
};

// Start transition to next track
AI_DJ.startTransition = function(nextTrackIndex, transition) {
    AI_DJ.state.isTransitioning = true;

    var blendDuration = transition.blend_duration || AI_DJ.config.blendDuration;

    AI_DJ.log("Starting transition...");
    AI_DJ.log("  Blend duration: " + blendDuration + "s");
    AI_DJ.log("  Strategy: " + transition.strategy);

    // Load next track
    AI_DJ.loadTrack(nextTrackIndex, AI_DJ.state.nextDeck);

    // Beatmatch if enabled
    if (AI_DJ.config.enableSync) {
        AI_DJ.beatmatch(AI_DJ.state.nextDeck);
    }

    // Start next deck playing
    engine.setValue(AI_DJ.state.nextDeck, "play", 1);

    // Execute crossfade over blend duration
    AI_DJ.crossfade(blendDuration);
};

// Beatmatch next deck to active deck
AI_DJ.beatmatch = function(deck) {
    AI_DJ.log("Beatmatching " + deck);

    // Enable sync on next deck
    engine.setValue(deck, "sync_enabled", 1);

    // Alternatively, manual BPM matching:
    // var activeBPM = engine.getValue(AI_DJ.state.activeDeck, "bpm");
    // var nextBPM = engine.getValue(deck, "bpm");
    // var ratio = activeBPM / nextBPM;
    // engine.setValue(deck, "rate", ratio - 1.0);
};

// Execute crossfade
AI_DJ.crossfade = function(duration) {
    AI_DJ.log("Crossfading over " + duration + " seconds");

    var steps = Math.floor(duration * 10); // 100ms per step
    var stepDuration = 100; // milliseconds
    var currentStep = 0;

    var crossfadeTimer = engine.beginTimer(stepDuration, function() {
        currentStep++;
        var progress = currentStep / steps;

        // Linear crossfade (could be exponential for smoother blend)
        var activeFader = 1.0 - progress;
        var nextFader = progress;

        engine.setValue(AI_DJ.state.activeDeck, "volume", activeFader);
        engine.setValue(AI_DJ.state.nextDeck, "volume", nextFader);

        if (currentStep >= steps) {
            // Crossfade complete
            engine.stopTimer(crossfadeTimer);
            AI_DJ.onTransitionComplete();
        }
    }, false);
};

// Transition complete callback
AI_DJ.onTransitionComplete = function() {
    AI_DJ.log("Transition complete");

    // Stop the old deck
    engine.setValue(AI_DJ.state.activeDeck, "play", 0);
    engine.setValue(AI_DJ.state.activeDeck, "volume", 1.0);

    // Swap decks
    var temp = AI_DJ.state.activeDeck;
    AI_DJ.state.activeDeck = AI_DJ.state.nextDeck;
    AI_DJ.state.nextDeck = temp;

    // Move to next track
    AI_DJ.state.currentTrackIndex++;
    AI_DJ.state.isTransitioning = false;

    // Check if playlist is complete
    if (AI_DJ.state.currentTrackIndex >= AI_DJ.state.playlist.tracks.length - 1) {
        AI_DJ.log("Playlist complete!");
    }
};

// Event handlers
AI_DJ.onPlayChanged = function(value, group, control) {
    // Track play state changes
};

AI_DJ.onPositionChanged = function(value, group, control) {
    // Track position changes
};

// Export public API
var AI_DJ_Controller = {
    init: AI_DJ.init,
    shutdown: AI_DJ.shutdown,
    loadPlaylist: AI_DJ.loadPlaylist,
    start: AI_DJ.start,
    stop: AI_DJ.stop,
    config: AI_DJ.config,
};
